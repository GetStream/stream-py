# Code generated by GetStream internal OpenAPI code generator. DO NOT EDIT.
from getstream.models import *
from getstream.stream_response import StreamResponse
from getstream.video import BaseCall


class Call(BaseCall):
    def get(
        self,
        members_limit: Optional[int] = None,
        ring: Optional[bool] = None,
        notify: Optional[bool] = None,
        video: Optional[bool] = None,
    ) -> StreamResponse[GetCallResponse]:
        response = self.client.get_call(
            type=self.call_type,
            id=self.id,
            members_limit=members_limit,
            ring=ring,
            notify=notify,
            video=video,
        )
        self._sync_from_response(response.data)
        return response

    def update(
        self,
        starts_at: Optional[datetime] = None,
        custom: Optional[Dict[str, object]] = None,
        settings_override: Optional[CallSettingsRequest] = None,
    ) -> StreamResponse[UpdateCallResponse]:
        response = self.client.update_call(
            type=self.call_type,
            id=self.id,
            starts_at=starts_at,
            custom=custom,
            settings_override=settings_override,
        )
        self._sync_from_response(response.data)
        return response

    def get_or_create(
        self,
        members_limit: Optional[int] = None,
        notify: Optional[bool] = None,
        ring: Optional[bool] = None,
        video: Optional[bool] = None,
        data: Optional[CallRequest] = None,
    ) -> StreamResponse[GetOrCreateCallResponse]:
        response = self.client.get_or_create_call(
            type=self.call_type,
            id=self.id,
            members_limit=members_limit,
            notify=notify,
            ring=ring,
            video=video,
            data=data,
        )
        self._sync_from_response(response.data)
        return response

    def block_user(self, user_id: str) -> StreamResponse[BlockUserResponse]:
        response = self.client.block_user(
            type=self.call_type, id=self.id, user_id=user_id
        )
        self._sync_from_response(response.data)
        return response

    def send_closed_caption(
        self,
        speaker_id: str,
        text: str,
        end_time: Optional[datetime] = None,
        language: Optional[str] = None,
        service: Optional[str] = None,
        start_time: Optional[datetime] = None,
        translated: Optional[bool] = None,
        user_id: Optional[str] = None,
        user: Optional[UserRequest] = None,
    ) -> StreamResponse[SendClosedCaptionResponse]:
        response = self.client.send_closed_caption(
            type=self.call_type,
            id=self.id,
            speaker_id=speaker_id,
            text=text,
            end_time=end_time,
            language=language,
            service=service,
            start_time=start_time,
            translated=translated,
            user_id=user_id,
            user=user,
        )
        self._sync_from_response(response.data)
        return response

    def delete(self, hard: Optional[bool] = None) -> StreamResponse[DeleteCallResponse]:
        response = self.client.delete_call(type=self.call_type, id=self.id, hard=hard)
        self._sync_from_response(response.data)
        return response

    def send_call_event(
        self,
        user_id: Optional[str] = None,
        custom: Optional[Dict[str, object]] = None,
        user: Optional[UserRequest] = None,
    ) -> StreamResponse[SendCallEventResponse]:
        response = self.client.send_call_event(
            type=self.call_type, id=self.id, user_id=user_id, custom=custom, user=user
        )
        self._sync_from_response(response.data)
        return response

    def collect_user_feedback(
        self,
        rating: int,
        sdk: str,
        sdk_version: str,
        reason: Optional[str] = None,
        user_session_id: Optional[str] = None,
        custom: Optional[Dict[str, object]] = None,
    ) -> StreamResponse[CollectUserFeedbackResponse]:
        response = self.client.collect_user_feedback(
            type=self.call_type,
            id=self.id,
            rating=rating,
            sdk=sdk,
            sdk_version=sdk_version,
            reason=reason,
            user_session_id=user_session_id,
            custom=custom,
        )
        self._sync_from_response(response.data)
        return response

    def go_live(
        self,
        recording_storage_name: Optional[str] = None,
        start_closed_caption: Optional[bool] = None,
        start_hls: Optional[bool] = None,
        start_recording: Optional[bool] = None,
        start_transcription: Optional[bool] = None,
        transcription_storage_name: Optional[str] = None,
    ) -> StreamResponse[GoLiveResponse]:
        response = self.client.go_live(
            type=self.call_type,
            id=self.id,
            recording_storage_name=recording_storage_name,
            start_closed_caption=start_closed_caption,
            start_hls=start_hls,
            start_recording=start_recording,
            start_transcription=start_transcription,
            transcription_storage_name=transcription_storage_name,
        )
        self._sync_from_response(response.data)
        return response

    def kick_user(
        self,
        user_id: str,
        block: Optional[bool] = None,
        kicked_by_id: Optional[str] = None,
        kicked_by: Optional[UserRequest] = None,
    ) -> StreamResponse[KickUserResponse]:
        response = self.client.kick_user(
            type=self.call_type,
            id=self.id,
            user_id=user_id,
            block=block,
            kicked_by_id=kicked_by_id,
            kicked_by=kicked_by,
        )
        self._sync_from_response(response.data)
        return response

    def end(self) -> StreamResponse[EndCallResponse]:
        response = self.client.end_call(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def update_call_members(
        self,
        remove_members: Optional[List[str]] = None,
        update_members: Optional[List[MemberRequest]] = None,
    ) -> StreamResponse[UpdateCallMembersResponse]:
        response = self.client.update_call_members(
            type=self.call_type,
            id=self.id,
            remove_members=remove_members,
            update_members=update_members,
        )
        self._sync_from_response(response.data)
        return response

    def mute_users(
        self,
        audio: Optional[bool] = None,
        mute_all_users: Optional[bool] = None,
        muted_by_id: Optional[str] = None,
        screenshare: Optional[bool] = None,
        screenshare_audio: Optional[bool] = None,
        video: Optional[bool] = None,
        user_ids: Optional[List[str]] = None,
        muted_by: Optional[UserRequest] = None,
    ) -> StreamResponse[MuteUsersResponse]:
        response = self.client.mute_users(
            type=self.call_type,
            id=self.id,
            audio=audio,
            mute_all_users=mute_all_users,
            muted_by_id=muted_by_id,
            screenshare=screenshare,
            screenshare_audio=screenshare_audio,
            video=video,
            user_ids=user_ids,
            muted_by=muted_by,
        )
        self._sync_from_response(response.data)
        return response

    def query_call_participants(
        self,
        limit: Optional[int] = None,
        filter_conditions: Optional[Dict[str, object]] = None,
    ) -> StreamResponse[QueryCallParticipantsResponse]:
        response = self.client.query_call_participants(
            type=self.call_type,
            id=self.id,
            limit=limit,
            filter_conditions=filter_conditions,
        )
        self._sync_from_response(response.data)
        return response

    def video_pin(self, session_id: str, user_id: str) -> StreamResponse[PinResponse]:
        response = self.client.video_pin(
            type=self.call_type, id=self.id, session_id=session_id, user_id=user_id
        )
        self._sync_from_response(response.data)
        return response

    def list_recordings(self) -> StreamResponse[ListRecordingsResponse]:
        response = self.client.list_recordings(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def get_call_report(
        self, session_id: Optional[str] = None
    ) -> StreamResponse[GetCallReportResponse]:
        response = self.client.get_call_report(
            type=self.call_type, id=self.id, session_id=session_id
        )
        self._sync_from_response(response.data)
        return response

    def start_rtmp_broadcasts(
        self, broadcasts: List[RTMPBroadcastRequest]
    ) -> StreamResponse[StartRTMPBroadcastsResponse]:
        response = self.client.start_rtmp_broadcasts(
            type=self.call_type, id=self.id, broadcasts=broadcasts
        )
        self._sync_from_response(response.data)
        return response

    def stop_all_rtmp_broadcasts(self) -> StreamResponse[StopAllRTMPBroadcastsResponse]:
        response = self.client.stop_all_rtmp_broadcasts(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def stop_rtmp_broadcast(
        self,
        name: str,
    ) -> StreamResponse[StopRTMPBroadcastsResponse]:
        response = self.client.stop_rtmp_broadcast(
            type=self.call_type,
            id=self.id,
            name=name,
        )
        self._sync_from_response(response.data)
        return response

    def start_hls_broadcasting(self) -> StreamResponse[StartHLSBroadcastingResponse]:
        response = self.client.start_hls_broadcasting(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def start_closed_captions(
        self,
        enable_transcription: Optional[bool] = None,
        external_storage: Optional[str] = None,
        language: Optional[str] = None,
        speech_segment_config: Optional[SpeechSegmentConfig] = None,
    ) -> StreamResponse[StartClosedCaptionsResponse]:
        response = self.client.start_closed_captions(
            type=self.call_type,
            id=self.id,
            enable_transcription=enable_transcription,
            external_storage=external_storage,
            language=language,
            speech_segment_config=speech_segment_config,
        )
        self._sync_from_response(response.data)
        return response

    def start_frame_recording(
        self, recording_external_storage: Optional[str] = None
    ) -> StreamResponse[StartFrameRecordingResponse]:
        response = self.client.start_frame_recording(
            type=self.call_type,
            id=self.id,
            recording_external_storage=recording_external_storage,
        )
        self._sync_from_response(response.data)
        return response

    def start_recording(
        self, recording_external_storage: Optional[str] = None
    ) -> StreamResponse[StartRecordingResponse]:
        response = self.client.start_recording(
            type=self.call_type,
            id=self.id,
            recording_external_storage=recording_external_storage,
        )
        self._sync_from_response(response.data)
        return response

    def start_transcription(
        self,
        enable_closed_captions: Optional[bool] = None,
        language: Optional[str] = None,
        transcription_external_storage: Optional[str] = None,
    ) -> StreamResponse[StartTranscriptionResponse]:
        response = self.client.start_transcription(
            type=self.call_type,
            id=self.id,
            enable_closed_captions=enable_closed_captions,
            language=language,
            transcription_external_storage=transcription_external_storage,
        )
        self._sync_from_response(response.data)
        return response

    def stop_hls_broadcasting(self) -> StreamResponse[StopHLSBroadcastingResponse]:
        response = self.client.stop_hls_broadcasting(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def stop_closed_captions(
        self, stop_transcription: Optional[bool] = None
    ) -> StreamResponse[StopClosedCaptionsResponse]:
        response = self.client.stop_closed_captions(
            type=self.call_type, id=self.id, stop_transcription=stop_transcription
        )
        self._sync_from_response(response.data)
        return response

    def stop_frame_recording(self) -> StreamResponse[StopFrameRecordingResponse]:
        response = self.client.stop_frame_recording(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def stop_live(
        self,
        continue_closed_caption: Optional[bool] = None,
        continue_hls: Optional[bool] = None,
        continue_recording: Optional[bool] = None,
        continue_rtmp_broadcasts: Optional[bool] = None,
        continue_transcription: Optional[bool] = None,
    ) -> StreamResponse[StopLiveResponse]:
        response = self.client.stop_live(
            type=self.call_type,
            id=self.id,
            continue_closed_caption=continue_closed_caption,
            continue_hls=continue_hls,
            continue_recording=continue_recording,
            continue_rtmp_broadcasts=continue_rtmp_broadcasts,
            continue_transcription=continue_transcription,
        )
        self._sync_from_response(response.data)
        return response

    def stop_recording(self) -> StreamResponse[StopRecordingResponse]:
        response = self.client.stop_recording(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def stop_transcription(
        self, stop_closed_captions: Optional[bool] = None
    ) -> StreamResponse[StopTranscriptionResponse]:
        response = self.client.stop_transcription(
            type=self.call_type, id=self.id, stop_closed_captions=stop_closed_captions
        )
        self._sync_from_response(response.data)
        return response

    def list_transcriptions(self) -> StreamResponse[ListTranscriptionsResponse]:
        response = self.client.list_transcriptions(type=self.call_type, id=self.id)
        self._sync_from_response(response.data)
        return response

    def unblock_user(self, user_id: str) -> StreamResponse[UnblockUserResponse]:
        response = self.client.unblock_user(
            type=self.call_type, id=self.id, user_id=user_id
        )
        self._sync_from_response(response.data)
        return response

    def video_unpin(
        self, session_id: str, user_id: str
    ) -> StreamResponse[UnpinResponse]:
        response = self.client.video_unpin(
            type=self.call_type, id=self.id, session_id=session_id, user_id=user_id
        )
        self._sync_from_response(response.data)
        return response

    def update_user_permissions(
        self,
        user_id: str,
        grant_permissions: Optional[List[str]] = None,
        revoke_permissions: Optional[List[str]] = None,
    ) -> StreamResponse[UpdateUserPermissionsResponse]:
        response = self.client.update_user_permissions(
            type=self.call_type,
            id=self.id,
            user_id=user_id,
            grant_permissions=grant_permissions,
            revoke_permissions=revoke_permissions,
        )
        self._sync_from_response(response.data)
        return response

    def delete_recording(
        self, session: str, filename: str
    ) -> StreamResponse[DeleteRecordingResponse]:
        response = self.client.delete_recording(
            type=self.call_type, id=self.id, session=session, filename=filename
        )
        self._sync_from_response(response.data)
        return response

    def delete_transcription(
        self, session: str, filename: str
    ) -> StreamResponse[DeleteTranscriptionResponse]:
        response = self.client.delete_transcription(
            type=self.call_type, id=self.id, session=session, filename=filename
        )
        self._sync_from_response(response.data)
        return response

    create = get_or_create
