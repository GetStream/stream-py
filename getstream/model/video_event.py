# coding: utf-8

"""
    Stream Video API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: v80.4.1
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from getstream.model import schemas  # noqa: F401


class VideoEvent(
    schemas.ComposedSchema,
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    The discriminator object for all websocket events, you should use this to map event payloads to their own type
    """

    class MetaOapg:
        @staticmethod
        def discriminator():
            return {
                "type": {
                    "BlockedUserEvent": BlockedUserEvent,
                    "CallAcceptedEvent": CallAcceptedEvent,
                    "CallBroadcastingStartedEvent": CallBroadcastingStartedEvent,
                    "CallBroadcastingStoppedEvent": CallBroadcastingStoppedEvent,
                    "CallCreatedEvent": CallCreatedEvent,
                    "CallEndedEvent": CallEndedEvent,
                    "CallMemberAddedEvent": CallMemberAddedEvent,
                    "CallMemberRemovedEvent": CallMemberRemovedEvent,
                    "CallMemberUpdatedEvent": CallMemberUpdatedEvent,
                    "CallMemberUpdatedPermissionEvent": CallMemberUpdatedPermissionEvent,
                    "CallReactionEvent": CallReactionEvent,
                    "CallRecordingStartedEvent": CallRecordingStartedEvent,
                    "CallRecordingStoppedEvent": CallRecordingStoppedEvent,
                    "CallRejectedEvent": CallRejectedEvent,
                    "CallUpdatedEvent": CallUpdatedEvent,
                    "ConnectedEvent": ConnectedEvent,
                    "CustomVideoEvent": CustomVideoEvent,
                    "HealthCheckEvent": HealthCheckEvent,
                    "PermissionRequestEvent": PermissionRequestEvent,
                    "UnblockedUserEvent": UnblockedUserEvent,
                    "UpdatedCallPermissionsEvent": UpdatedCallPermissionsEvent,
                    "call.accepted": CallAcceptedEvent,
                    "call.blocked_user": BlockedUserEvent,
                    "call.broadcasting_started": CallBroadcastingStartedEvent,
                    "call.broadcasting_stopped": CallBroadcastingStoppedEvent,
                    "call.created": CallCreatedEvent,
                    "call.ended": CallEndedEvent,
                    "call.member_added": CallMemberAddedEvent,
                    "call.member_removed": CallMemberRemovedEvent,
                    "call.member_updated": CallMemberUpdatedEvent,
                    "call.permission_request": PermissionRequestEvent,
                    "call.permissions_updated": UpdatedCallPermissionsEvent,
                    "call.reaction_new": CallReactionEvent,
                    "call.recording_started": CallRecordingStartedEvent,
                    "call.recording_stopped": CallRecordingStoppedEvent,
                    "call.rejected": CallRejectedEvent,
                    "call.unblocked_user": UnblockedUserEvent,
                    "call.updated": CallUpdatedEvent,
                    "call.updated_permission": CallMemberUpdatedPermissionEvent,
                    "connection.ok": ConnectedEvent,
                    "custom": CustomVideoEvent,
                    "health.check": HealthCheckEvent,
                }
            }

        @classmethod
        @functools.lru_cache()
        def one_of(cls):
            # we need this here to make our import statements work
            # we must store _composed_schemas in here so the code is only run
            # when we invoke this method. If we kept this at the class
            # level we would get an error because the class level
            # code would be run when this module is imported, and these composed
            # classes don't exist yet because their module has not finished
            # loading
            return [
                BlockedUserEvent,
                CallAcceptedEvent,
                CallBroadcastingStartedEvent,
                CallBroadcastingStoppedEvent,
                CallCreatedEvent,
                CallEndedEvent,
                CallMemberAddedEvent,
                CallMemberRemovedEvent,
                CallMemberUpdatedEvent,
                CallMemberUpdatedPermissionEvent,
                CallReactionEvent,
                CallRecordingStartedEvent,
                CallRecordingStoppedEvent,
                CallRejectedEvent,
                CallUpdatedEvent,
                ConnectedEvent,
                CustomVideoEvent,
                HealthCheckEvent,
                PermissionRequestEvent,
                UnblockedUserEvent,
                UpdatedCallPermissionsEvent,
            ]

    def __new__(
        cls,
        *_args: typing.Union[
            dict,
            frozendict.frozendict,
            str,
            date,
            datetime,
            uuid.UUID,
            int,
            float,
            decimal.Decimal,
            bool,
            None,
            list,
            tuple,
            bytes,
            io.FileIO,
            io.BufferedReader,
        ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[
            schemas.AnyTypeSchema,
            dict,
            frozendict.frozendict,
            str,
            date,
            datetime,
            uuid.UUID,
            int,
            float,
            decimal.Decimal,
            None,
            list,
            tuple,
            bytes,
        ],
    ) -> "VideoEvent":
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )


from getstream.model.blocked_user_event import BlockedUserEvent
from getstream.model.call_accepted_event import CallAcceptedEvent
from getstream.model.call_broadcasting_started_event import (
    CallBroadcastingStartedEvent,
)
from getstream.model.call_broadcasting_stopped_event import (
    CallBroadcastingStoppedEvent,
)
from getstream.model.call_created_event import CallCreatedEvent
from getstream.model.call_ended_event import CallEndedEvent
from getstream.model.call_member_added_event import CallMemberAddedEvent
from getstream.model.call_member_removed_event import CallMemberRemovedEvent
from getstream.model.call_member_updated_event import CallMemberUpdatedEvent
from getstream.model.call_member_updated_permission_event import (
    CallMemberUpdatedPermissionEvent,
)
from getstream.model.call_reaction_event import CallReactionEvent
from getstream.model.call_recording_started_event import CallRecordingStartedEvent
from getstream.model.call_recording_stopped_event import CallRecordingStoppedEvent
from getstream.model.call_rejected_event import CallRejectedEvent
from getstream.model.call_updated_event import CallUpdatedEvent
from getstream.model.connected_event import ConnectedEvent
from getstream.model.custom_video_event import CustomVideoEvent
from getstream.model.health_check_event import HealthCheckEvent
from getstream.model.permission_request_event import PermissionRequestEvent
from getstream.model.unblocked_user_event import UnblockedUserEvent
from getstream.model.updated_call_permissions_event import UpdatedCallPermissionsEvent
